<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<base href="http://souktha.github.io/software/bblk-ir/">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Creating an IR receiver on AM335x BeagleBone Black | Soukthavy Sopha</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="http://souktha.github.io/software/bblk-ir/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Soukthavy">
<link rel="prev" href="../../hardware/runlenth/" title="Run-length encoding with FPGA" type="text/html">
<link rel="next" href="../../hardware/vga-display-xadc/" title="Displaying Xilinx XADC on VGA" type="text/html">
<meta property="og:site_name" content="Soukthavy Sopha">
<meta property="og:title" content="Creating an IR receiver on AM335x BeagleBone Black">
<meta property="og:url" content="http://souktha.github.io/software/bblk-ir/">
<meta property="og:description" content="What I like about working with TI based platform is their easily accessible documentations. It is by far the most
developers friendly unlike other chip vendors. This accessibility has enable me to exp">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2016-04-02T15:39:02Z">
<meta property="article:tag" content="software">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://souktha.github.io/">

                <span id="blog-title">Soukthavy Sopha</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>
                </li>
<li>
<a href="../../rss.xml">RSS feed</a>
            </li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Blog <b class="caret"></b></a>
            <ul class="dropdown-menu">
<li>
<a href="../../software">Sofware</a>
                    </li>
<li>
<a href="../../hardware">Hardware</a>
                    </li>
<li>
<a href="../../misc">Misc</a>
            </li>
</ul>
</li>
<li>
<a href="https://github.com/souktha">My Github</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="storypage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Creating an IR receiver on AM335x BeagleBone Black</a></h1>

        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>What I like about working with TI based platform is their easily accessible documentations. It is by far the most
developers friendly unlike other chip vendors. This accessibility has enable me to experiment with the on-chip I/O
subsystem components.</p>
<!-- TEASER_END -->
<p>TI OMAP AM335x <a class="footnote-reference" href="#id7" id="id1">[1]</a> has wealth of I/O devices that can be put to good use. Among various supported I/O devices are six UART devices.
Among these six UARTs, I think only UART0 is used for serial port routed to the 6-pin header, J1. The rest of them share with
other I/O devices by multiplexing (pinmux). I want to create and IR receiver from one of the remaining UART devices and I choose
to use UART4 for that. The reason being that UART4 is routed to P9 and can be pinmuxed to make use of it. Its RXD will be at
pin 11 of P9. Should I choose UART5, it will conflict with LCD muxed pins. Table 13 <a class="footnote-reference" href="#id8" id="id2">[2]</a> of the BBLK shows UART4_RXD right at
the stop just below <em>sys_resetn</em>, this too caught my attention. It is just the one that pops up get to be picked and I decide to
write the Linux IR device driver for it.</p>
<div class="section" id="ir-receiver">
<h2>IR receiver</h2>
<p>There are various IR receiver device drivers readily available in the kernel and they work in most cases. Most of them support
mainstream IR devices that are commercially available. In the Linux device drivers structure, the IR is a subcategory of media device drivers.</p>
<div class="section" id="ir-device">
<h3>IR device</h3>
<p>For this work, I am using a VS1838B IR receiver having three pins, power, ground, and output. I do not even have the datasheet of it. I hook
it up and get the scope output and from what I see I know that it will work for what I want to do.</p>
<div class="figure">
<img alt="../../images/hardware/IR.BMP" src="../../images/hardware/IR.BMP"><p class="caption">IR signal from its output pin</p>
</div>
<p>This device is probably equivalent to TSOP4838 or TSOP1738 type of IR receiver, an integrated circuit with AGC and BP filter.</p>
<div class="figure">
<img alt="../../images/hardware/connecting-ir.jpg" src="../../images/hardware/connecting-ir.jpg"><p class="caption">This is how easy it is to connect. Two pins plug straight to header with the signal pin to UART4_RXD.</p>
</div>
</div>
</div>
<div class="section" id="tools-software-and-accessory">
<h2>Tools, software and accessory</h2>
<ul class="simple">
<li>IR receiver</li>
<li>Wires</li>
<li>Any IR remote controller transmitter (from old VCR or old TV etc..)</li>
<li>v4l-utils tool, ir-keytable for testing.</li>
<li>BeagleBone Black</li>
</ul>
</div>
<div class="section" id="implementation">
<h2>Implementation</h2>
<div class="section" id="pinmuxing">
<h3>pinmuxing</h3>
<p>The IR driver will be running on the current kernel version of my BBLK board which is 4.1.13. The kernel source file is in <em>am335x-evm-sdk-src-02.00.01.07</em> of TI.
First thing I need to do is to redo pinmux for <em>T17</em> (Table 4.1, page 29) <a class="footnote-reference" href="#id10" id="id3">[4]</a>. <em>T17</em> is the ball pin of Am3358, not the BBLK P9's header pin. On P9 it is pin 11.
This is the pin for UART4_RXD. For this pin to function as UART4_RXD, it needs to be muxed to mode 6 of operation.
To pinmux, I need to edit the device tree source, am335x-boneblack.dts, and add to '&amp;am33xx_pinmux' block to override their default settings.
I do not need TX operation of this UART since it is only for RX operation.</p>
<pre class="code text"><a name="rest_code_eb309e97f76c41679b705762b302edae-1"></a>&amp;am33xx_pinmux {
<a name="rest_code_eb309e97f76c41679b705762b302edae-2"></a>         ..
<a name="rest_code_eb309e97f76c41679b705762b302edae-3"></a>
<a name="rest_code_eb309e97f76c41679b705762b302edae-4"></a>         uart4_pins: pinmux_uart4_pins {
<a name="rest_code_eb309e97f76c41679b705762b302edae-5"></a>         pinctrl-single,pins = &lt;
<a name="rest_code_eb309e97f76c41679b705762b302edae-6"></a>                 0x70 (PIN_INPUT_PULLUP | MUX_MODE6)     /* uart4_rxd.uart4_rxd*/
<a name="rest_code_eb309e97f76c41679b705762b302edae-7"></a>         &gt;;
<a name="rest_code_eb309e97f76c41679b705762b302edae-8"></a>        };
<a name="rest_code_eb309e97f76c41679b705762b302edae-9"></a> };
</pre>
<p>I also need to enable UART4 that was defined, but was marked disabled otherwise I will not be able to use it. I can override this setting by
adding the following to the dts file,</p>
<pre class="code text"><a name="rest_code_72aacc1538414d6d9769272c39410b45-1"></a>&amp;uart4 {
<a name="rest_code_72aacc1538414d6d9769272c39410b45-2"></a>        pinctrl-names = "default";
<a name="rest_code_72aacc1538414d6d9769272c39410b45-3"></a>        pinctrl-0 = &lt;&amp;uart4_pins&gt;;
<a name="rest_code_72aacc1538414d6d9769272c39410b45-4"></a>        compatible = "cir-uart";
<a name="rest_code_72aacc1538414d6d9769272c39410b45-5"></a>        status = "okay";
<a name="rest_code_72aacc1538414d6d9769272c39410b45-6"></a>};
</pre>
<p>So I add the block shown above just below '&amp;mcasp0' block. This is to set 'uart4' to use the pinmux that I define and set its status to be okay (enable).
I also set the platform driver compatibilty to 'cir-uart'. This is going to be my new IR driver. The platform driver will invoke my driver upon
<em>insmod</em>. I am done with pinmuxing and enabling UART4 device as far as device tree is concerned.</p>
<p>I recompile the device tree and add to the zImage as an FDT. On reboot, the new MUX will take effect.
The simple part is done, now come the hard part. Getting the UART4 to work the way I want to.</p>
</div>
<div class="section" id="kernel-driver">
<h3>kernel driver</h3>
<p>In reference to TI's AM335x <a class="footnote-reference" href="#id7" id="id4">[1]</a>, chapter 19, Universal Receiver/Transmitter, the clock for this UART is the external <em>PER_CLKOUTM2</em> <em>PRCM / 4</em> that feeds the UART's <em>fclk</em>.  The UART has to be clocked for the driver to be able to access its registers and configure it for use.</p>
<p>The first thing this driver does is to register with the kernel platform framework having this <em>platform_driver</em> table,</p>
<pre class="code text"><a name="rest_code_5c108421c95c46b5a11d3897fe78421a-1"></a>static struct platform_driver cir_platform_driver = {
<a name="rest_code_5c108421c95c46b5a11d3897fe78421a-2"></a>        .driver = {
<a name="rest_code_5c108421c95c46b5a11d3897fe78421a-3"></a>        .name           = "cir-uart",
<a name="rest_code_5c108421c95c46b5a11d3897fe78421a-4"></a>        .of_match_table = cir_dt_ids,
<a name="rest_code_5c108421c95c46b5a11d3897fe78421a-5"></a>        },
<a name="rest_code_5c108421c95c46b5a11d3897fe78421a-6"></a>        .probe                  = cir_probe,
<a name="rest_code_5c108421c95c46b5a11d3897fe78421a-7"></a>        .remove                 = cir_remove,
<a name="rest_code_5c108421c95c46b5a11d3897fe78421a-8"></a>};
</pre>
<p>The <em>cir-uart</em> matches to what I defined in the device tree earlier. The will enable the platform driver framework to call
its <em>cir_probe</em> for device probing and initializing the device.</p>
<pre class="code text"><a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-1"></a>static int cir_probe(struct platform_device * pdev)
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-2"></a>{
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-3"></a>        ...
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-4"></a>
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-5"></a>        struct resource * regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-6"></a>        struct resource * irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-7"></a>        ...
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-8"></a>        /* use uart4_fck*/
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-9"></a>        clk = clk_get(&amp;pdev-&gt;dev,"dpll_per_m2_div4_ck"); //expect 48MHZ clock feed
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-10"></a>        ..
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-11"></a>
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-12"></a>        device_init_wakeup(&amp;pdev-&gt;dev, true);
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-13"></a>        pm_runtime_use_autosuspend(&amp;pdev-&gt;dev);
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-14"></a>        pm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev,-1);
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-15"></a>        pm_runtime_irq_safe(&amp;pdev-&gt;dev);
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-16"></a>        pm_runtime_enable(&amp;pdev-&gt;dev);
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-17"></a>
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-18"></a>        pm_runtime_get_sync(&amp;pdev-&gt;dev);
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-19"></a>
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-20"></a>        cirdev-&gt;clk = clk;
<a name="rest_code_ac21fcb47be64f4d884bfec566f89eb2-21"></a>        clk_prepare_enable(clk);
</pre>
<p>The device probe get the device resource information from the platfrom framework. I look up the source
code in <em>arch/arm/mach-omap2</em> to find out the name of the clock that is the most likely be the one I should be
using. This happens to be <em>dll_per_m2_div4_ck</em> clock. The driver will get this clock line, wakeup the device and
ask <em>pm_runtime..</em> to put it into use. The remaining part is the typical drill, memory mapped I/O device, request IRQ
line etc..</p>
<p>Next the driver allocates RC device structure, fills in the RC device operations and its information and register
for service with the RC framework driver. In the RC device structure, I have mostly empty functions
defined since the device does not need special handling. It is only for the formality. I have it mapped to
<em>RC_MAP_RC6_MCE</em>, but it can be changed at run-time. Work queue is also used for this
driver for input event processing as the BH portion of interrupt handling.</p>
<pre class="code text"><a name="rest_code_c1b90a20714947c085538bdd5650b7fa-1"></a>ir_props = rc_allocate_device();
<a name="rest_code_c1b90a20714947c085538bdd5650b7fa-2"></a>..
<a name="rest_code_c1b90a20714947c085538bdd5650b7fa-3"></a>ir_props-&gt;driver_type = RC_DRIVER_IR_RAW;
<a name="rest_code_c1b90a20714947c085538bdd5650b7fa-4"></a>ir_props-&gt;allowed_protocols = RC_BIT_ALL;
<a name="rest_code_c1b90a20714947c085538bdd5650b7fa-5"></a>ir_props-&gt;priv = (void * )cirdev;
<a name="rest_code_c1b90a20714947c085538bdd5650b7fa-6"></a>ir_props-&gt;s_idle = cir_set_idle;
<a name="rest_code_c1b90a20714947c085538bdd5650b7fa-7"></a>ir_props-&gt;open = cir_open;
<a name="rest_code_c1b90a20714947c085538bdd5650b7fa-8"></a>ir_props-&gt;close = cir_close;
<a name="rest_code_c1b90a20714947c085538bdd5650b7fa-9"></a>..
<a name="rest_code_c1b90a20714947c085538bdd5650b7fa-10"></a>ir_props-&gt;map_name = RC_MAP_RC6_MCE;
<a name="rest_code_c1b90a20714947c085538bdd5650b7fa-11"></a>..
<a name="rest_code_c1b90a20714947c085538bdd5650b7fa-12"></a>INIT_WORK((struct work_struct * )&amp;cirdev-&gt;bh,irevent_bh);
<a name="rest_code_c1b90a20714947c085538bdd5650b7fa-13"></a>INIT_LIST_HEAD((struct list_head * )&amp;cirdev-&gt;head);
<a name="rest_code_c1b90a20714947c085538bdd5650b7fa-14"></a>
<a name="rest_code_c1b90a20714947c085538bdd5650b7fa-15"></a>err = rc_register_device(cirdev-&gt;irprops);
</pre>
<p>The UART is at the reset state and won't get initialized until the RC called its <em>cir_open()</em> operation. This will happen
when <em>/dev/input/eventx</em> is opened by external application to make use of it.</p>
<p>Once the IR stream bits is received and decoded by the UART, the RX interrupt will be generated and will be serviced
by <em>cir_irq_handler</em> interrupt handler. The handler put the received byte into the buffer and schedule the BH workqueue.
The BH handler then takes the byte off from the buffer and pushes it upstream to the IR core driver.</p>
<pre class="code text"><a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-1"></a>..
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-2"></a>if ( (pulse == 0) || (pulse == 0xff) ) {
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-3"></a>        ev.pulse = pulse ? 1 : 0 ;
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-4"></a>        ev.duration = (protocol == RC_TYPE_SONY12 ) ? 600000 * 8: 562500 * 8 ;
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-5"></a>        ir_raw_event_store_with_filter(cirdev-&gt;irprops, &amp;ev);
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-6"></a>        continue;
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-7"></a>}
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-8"></a>
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-9"></a>for (j = 0; j &lt; 8; j++) {
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-10"></a>        ev.pulse = pulse &amp; 1;
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-11"></a>        pulse = pulse &gt;&gt; 1;
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-12"></a>        if (protocol == RC_TYPE_SONY12) {
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-13"></a>                ev.duration = 600000 ; //duration * 1000; //in ns
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-14"></a>        }
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-15"></a>        else
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-16"></a>                ev.duration = 562500; //duration * 1000; //in ns
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-17"></a>                ir_raw_event_store_with_filter(cirdev-&gt;irprops, &amp;ev);
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-18"></a>        }
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-19"></a>         ..
<a name="rest_code_bb4daa3300444c4086baf8e01d08cce2-20"></a>ir_raw_event_handle(cirdev-&gt;irprops);
</pre>
<p>For simplicity, I omit the sleep/wakeup support in the driver, instead I add proc file interface for
debugging purpose. The proc file is a simple registers dump using sequential file mechanism.</p>
<pre class="code text"><a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-1"></a>struct file_operations proc_regs_fops = {
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-2"></a>        .open =  proc_seq_open,
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-3"></a>        .read = seq_read,
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-4"></a>        .llseek = seq_lseek,
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-5"></a>        .write = proc_reg_write,
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-6"></a>        .owner = THIS_MODULE,
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-7"></a>};
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-8"></a>..
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-9"></a>
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-10"></a>if (!(cir_procdir_entry = proc_mkdir("cir",NULL))) {
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-11"></a>        goto exit_free_data;
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-12"></a>}
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-13"></a>cirdev-&gt;proc_entry = cir_procdir_entry;
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-14"></a>if (!(entry = proc_create_data("regs",S_IFREG | S_IRUGO | S_IWUSR,
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-15"></a>                                                           cirdev-&gt;proc_entry,
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-16"></a>                                                           &amp;proc_regs_fops,
<a name="rest_code_267ec4f688fc47608bcb6cce42141ee7-17"></a>                                                           NULL)) ) {
</pre>
<p>Once I compile the driver, <em>cir.ko</em>, I can load and test it. As part of input event, the input event driver, <em>evdev</em> is also used.</p>
<pre class="code text"><a name="rest_code_8b02d6d1aefa4ce2a693c154d5794e84-1"></a># modprobe evdev
<a name="rest_code_8b02d6d1aefa4ce2a693c154d5794e84-2"></a># insmod cir.ko
</pre>
</div>
</div>
<div class="section" id="testing">
<h2>Testing</h2>
<p>Having the debug code, upon driver loading I can see that the platform framework call it with,</p>
<pre class="code text"><a name="rest_code_74be4d82e6184f1996b2d8df4d9ea0b4-1"></a># insmod ci# insmod cir.ko
<a name="rest_code_74be4d82e6184f1996b2d8df4d9ea0b4-2"></a>[   40.972690] cir_probe: entering with regs start 0x481a8000, size 0x2000, irq 156
<a name="rest_code_74be4d82e6184f1996b2d8df4d9ea0b4-3"></a>[   40.980266] cir_probe:uartclk 48000000, wakeirq 0, id   (null), sbase 0xfa1a8000, mapbase 481a8000
<a name="rest_code_74be4d82e6184f1996b2d8df4d9ea0b4-4"></a>[   40.990945] cir_probe: fck rate 48000000
</pre>
<p>So far so good. My debugging messages indicate that I get the UART4 resource information correctly.To make sure I get what
I think I really get is to add few extra debug code to actually read the AM3358 registers <a class="footnote-reference" href="#id7" id="id5">[1]</a> just to verify the setting.</p>
<pre class="code text"><a name="rest_code_bec001d81c9640bdb039259b91b465c5-1"></a>[   99.034228] get_uart_clock, CM_PER_L4LS_CLKCTRL=0x4502
<a name="rest_code_bec001d81c9640bdb039259b91b465c5-2"></a>[   99.039409] get_uart_clock, CM_PER_UART4_CLKCTRL=0x2
<a name="rest_code_bec001d81c9640bdb039259b91b465c5-3"></a>[   99.045336] get_uart_clock: MDR1 reg = 0x7, CFPS 0x69
</pre>
<p>The first two lines is the value of <em>CM_PER_L4LS_CLKCTRL</em> <a class="footnote-reference" href="#id7" id="id6">[1]</a> and <em>CM_PER_UART4_CLKCTRL</em> respectively. This is the
indication that clock line is activated correctly. The last line is to read two UART registers, <em>MDR1</em> and
<em>CFPS</em>. If clock line is not activated, reading the two UART registers would have resulted in kernel crash
because the IO bus would be stuck and cause I/O fault to happen. It is the painful way to know something is wrong.</p>
<p>I can check IRQ45 of UART4 is registered with the kernel correctly.</p>
<pre class="code text"><a name="rest_code_31e6eb34001c4a03a5e8e06717fcacc1-1"></a># cat /proc/interrupts
<a name="rest_code_31e6eb34001c4a03a5e8e06717fcacc1-2"></a>           CPU0
<a name="rest_code_31e6eb34001c4a03a5e8e06717fcacc1-3"></a> 16:       3050      INTC  68 Level     gp_timer
<a name="rest_code_31e6eb34001c4a03a5e8e06717fcacc1-4"></a> ...
<a name="rest_code_31e6eb34001c4a03a5e8e06717fcacc1-5"></a>156:          0      INTC  45 Level     cir
<a name="rest_code_31e6eb34001c4a03a5e8e06717fcacc1-6"></a>...
</pre>
<p>There is my interrupt handler and current count is at 0. While at it I can check my proc file for registers dump at
the device's idle state.</p>
<pre class="code text"><a name="rest_code_058b6a046a3f4a3b850da8b8bb149e3c-1"></a># cat /proc/cir/regs
<a name="rest_code_058b6a046a3f4a3b850da8b8bb149e3c-2"></a>rhr                      0x44
<a name="rest_code_058b6a046a3f4a3b850da8b8bb149e3c-3"></a>acreg                    0x10
<a name="rest_code_058b6a046a3f4a3b850da8b8bb149e3c-4"></a>..
</pre>
<p>Having verify the information that I expect, I have more confident to do further test. The next step is to
test with <em>ir-keytable</em> utility.</p>
<pre class="code text"><a name="rest_code_cd64143eae4d437ebbe47fa29669e648-1"></a># ir-keytable
<a name="rest_code_cd64143eae4d437ebbe47fa29669e648-2"></a>Found /sys/class/rc/rc0/ (/dev/input/event0) with:
<a name="rest_code_cd64143eae4d437ebbe47fa29669e648-3"></a>        Driver (null), table rc-rc6-mce
<a name="rest_code_cd64143eae4d437ebbe47fa29669e648-4"></a>        Supported protocols: unknown other lirc rc-5 jvc sony nec sanyo mce-kbd rc-6 sharp xmp
<a name="rest_code_cd64143eae4d437ebbe47fa29669e648-5"></a>        Enabled protocols: lirc rc-6
<a name="rest_code_cd64143eae4d437ebbe47fa29669e648-6"></a>        Name: CIR Infrared Remote Receiver
<a name="rest_code_cd64143eae4d437ebbe47fa29669e648-7"></a>        bus: 0, vendor/product: 0000:0000, version: 0x0000
<a name="rest_code_cd64143eae4d437ebbe47fa29669e648-8"></a>        Repeat delay = 500 ms, repeat period = 125 ms
</pre>
<p>Looks like the tool recognize the registered IR device. I will change to use SONY protocol instead of
<em>lirc rc-6</em> so I issue this command,</p>
<pre class="code text"><a name="rest_code_b9fbbff2719c44649eecbf7dc05d5bc8-1"></a># ir-keytable -c -p SONY
<a name="rest_code_b9fbbff2719c44649eecbf7dc05d5bc8-2"></a>Old keytable cleared
<a name="rest_code_b9fbbff2719c44649eecbf7dc05d5bc8-3"></a>Protocols changed to sony
<a name="rest_code_b9fbbff2719c44649eecbf7dc05d5bc8-4"></a># ir-keytable
<a name="rest_code_b9fbbff2719c44649eecbf7dc05d5bc8-5"></a>Found /sys/class/rc/rc0/ (/dev/input/event0) with:
<a name="rest_code_b9fbbff2719c44649eecbf7dc05d5bc8-6"></a>        Driver (null), table rc-rc6-mce
<a name="rest_code_b9fbbff2719c44649eecbf7dc05d5bc8-7"></a>        Supported protocols: unknown other lirc rc-5 jvc sony nec sanyo mce-kbd rc-6 sharp xmp
<a name="rest_code_b9fbbff2719c44649eecbf7dc05d5bc8-8"></a>        Enabled protocols: sony
<a name="rest_code_b9fbbff2719c44649eecbf7dc05d5bc8-9"></a>        Name: CIR Infrared Remote Receiver
<a name="rest_code_b9fbbff2719c44649eecbf7dc05d5bc8-10"></a>        bus: 0, vendor/product: 0000:0000, version: 0x0000
<a name="rest_code_b9fbbff2719c44649eecbf7dc05d5bc8-11"></a>        Repeat delay = 500 ms, repeat period = 125 ms
</pre>
<p>So far so good. Next is to run the test with the IR receiver and SONY based remote control I found
in my junk box.</p>
<pre class="code text"><a name="rest_code_813b3cc3ca4840bbb9abbfcf56fc2866-1"></a># ir-keytable -t
<a name="rest_code_813b3cc3ca4840bbb9abbfcf56fc2866-2"></a>Testing events. Please, press CTRL-C to abort.
<a name="rest_code_813b3cc3ca4840bbb9abbfcf56fc2866-3"></a>1214.743017: event type EV_MSC(0x04): scancode = 0x19000a
<a name="rest_code_813b3cc3ca4840bbb9abbfcf56fc2866-4"></a>1214.743017: event type EV_SYN(0x00).
<a name="rest_code_813b3cc3ca4840bbb9abbfcf56fc2866-5"></a>...
<a name="rest_code_813b3cc3ca4840bbb9abbfcf56fc2866-6"></a>218.540761: event type EV_MSC(0x04): scancode = 0x19000b
<a name="rest_code_813b3cc3ca4840bbb9abbfcf56fc2866-7"></a>1218.540761: event type EV_SYN(0x00).
<a name="rest_code_813b3cc3ca4840bbb9abbfcf56fc2866-8"></a>1218.585536: event type EV_MSC(0x04): scancode = 0x19000b
</pre>
<p>Scan code of SONY remote control is detected and decoded. For <em>power</em> button it is 0x1900a and for <em>menu</em>
button it is 0x19000b. With this information, I can create the keymaps for it. Luckily this remote control
has only a small number of buttons so it is created quickly. I store this keymap file as <em>sony</em> in
<em>/etc/rc_keymaps</em>.</p>
<pre class="code text"><a name="rest_code_e114047b1c0a4a80bb121dfe710a5042-1"></a># cat /etc/rc_keymaps/sony
<a name="rest_code_e114047b1c0a4a80bb121dfe710a5042-2"></a>0x19000a KEY_POWER
<a name="rest_code_e114047b1c0a4a80bb121dfe710a5042-3"></a>0x19000b KEY_MENU
<a name="rest_code_e114047b1c0a4a80bb121dfe710a5042-4"></a>0x19000c KEY_UP
<a name="rest_code_e114047b1c0a4a80bb121dfe710a5042-5"></a>0x19000d KEY_REWIND
<a name="rest_code_e114047b1c0a4a80bb121dfe710a5042-6"></a>0x19000e KEY_ENTER
<a name="rest_code_e114047b1c0a4a80bb121dfe710a5042-7"></a>0x19000f KEY_FORWARD
<a name="rest_code_e114047b1c0a4a80bb121dfe710a5042-8"></a>0x190010 KEY_DOWN
</pre>
<p>Next I load the keymap mapping for the next test.</p>
<pre class="code text"><a name="rest_code_ff9d827c8a3d4906829171ac03c0828b-1"></a># ir-keytable -c -p sony -w /etc/rc_keymaps/sony
<a name="rest_code_ff9d827c8a3d4906829171ac03c0828b-2"></a>Old keytable cleared
<a name="rest_code_ff9d827c8a3d4906829171ac03c0828b-3"></a>Wrote 7 keycode(s) to driver
<a name="rest_code_ff9d827c8a3d4906829171ac03c0828b-4"></a>Protocols changed to sony
<a name="rest_code_ff9d827c8a3d4906829171ac03c0828b-5"></a># ir-keytable -t
<a name="rest_code_ff9d827c8a3d4906829171ac03c0828b-6"></a>Testing events. Please, press CTRL-C to abort.
<a name="rest_code_ff9d827c8a3d4906829171ac03c0828b-7"></a>1608.313105: event type EV_MSC(0x04): scancode = 0x19000a
<a name="rest_code_ff9d827c8a3d4906829171ac03c0828b-8"></a>1608.313105: event type EV_KEY(0x01) key_down: KEY_POWER(0x0001)
<a name="rest_code_ff9d827c8a3d4906829171ac03c0828b-9"></a>1608.313105: event type EV_SYN(0x00).
<a name="rest_code_ff9d827c8a3d4906829171ac03c0828b-10"></a>...
<a name="rest_code_ff9d827c8a3d4906829171ac03c0828b-11"></a>1613.269840: event type EV_MSC(0x04): scancode = 0x190010
<a name="rest_code_ff9d827c8a3d4906829171ac03c0828b-12"></a>1613.269840: event type EV_KEY(0x01) key_down: KEY_DOWN(0x0001)
<a name="rest_code_ff9d827c8a3d4906829171ac03c0828b-13"></a>1613.269840: event type EV_SYN(0x00).
</pre>
<p>Now that I can see that the key events are generated with respect to their scancodes. Changing
protocol to match the type of remote control is also flexible, for example, I can change
protocol to NEC, <em>nec</em> to use with an old TV remote control that uses NEC protocol,</p>
<pre class="code text"><a name="rest_code_00b939c8eea8402b9f9dc128b53c110c-1"></a># ir-keytable -c -p nec
<a name="rest_code_00b939c8eea8402b9f9dc128b53c110c-2"></a>Old keytable cleared
<a name="rest_code_00b939c8eea8402b9f9dc128b53c110c-3"></a>Protocols changed to nec
<a name="rest_code_00b939c8eea8402b9f9dc128b53c110c-4"></a># ir-keytable -t
<a name="rest_code_00b939c8eea8402b9f9dc128b53c110c-5"></a>Testing events. Please, press CTRL-C to abort.
<a name="rest_code_00b939c8eea8402b9f9dc128b53c110c-6"></a>2280.369927: event type EV_MSC(0x04): scancode = 0x847904
<a name="rest_code_00b939c8eea8402b9f9dc128b53c110c-7"></a>2280.369927: event type EV_SYN(0x00).
<a name="rest_code_00b939c8eea8402b9f9dc128b53c110c-8"></a>2285.859057: event type EV_MSC(0x04): scancode = 0x84790a
<a name="rest_code_00b939c8eea8402b9f9dc128b53c110c-9"></a>2285.859057: event type EV_SYN(0x00).
</pre>
<p>Should I need to use this remote control, I would want to create the keymap for its scancodes; however,
this remote control has too many buttons, I will not create keymap for it for the time being. The scancodes
above are for <em>play</em> and <em>stop</em> buttons respectively. They would be mapped to <em>KEY_PLAY</em> and <em>KEY_STOP</em> of
the map file.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>While there are many choices to use the IR of this type. One would be the GPIO type of driver to handle the
IR stream, perhaps bit-banging it. If there is a small piece of hardware that left unused, it is better
to use it. Since it is already included in the cost of the product, I better find the use of it.</p>
<p>This driver is available in my github repository, <a class="reference external" href="https://github.com/souktha/ir">https://github.com/souktha/ir</a>. There is a lot of room to
improve and it is not yet robust. If I load/unload multiple times, it would crash. Once I have enough time
in my hand, I will fix it. Perhaps it is because I oversimplify it by ignoring certain aspect of <em>pm_runtime</em>.</p>
</div>
<div class="section" id="citations">
<h2>Citations</h2>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup>
<col class="label">
<col>
</colgroup>
<tbody valign="top"><tr>
<td class="label">[1]</td>
<td>
<em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id4">2</a>, <a class="fn-backref" href="#id5">3</a>, <a class="fn-backref" href="#id6">4</a>)</em> AM335x Sitara Processors Technical Reference Manual, Literature number: SPRUH73M, October 2011 - Revised January 2016, Texas Instruments.</td>
</tr></tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup>
<col class="label">
<col>
</colgroup>
<tbody valign="top"><tr>
<td class="label"><a class="fn-backref" href="#id2">[2]</a></td>
<td>BeagleBone Black System Reference Manual, Revision C.1, May 22, 2014, Gerald Coley, Robert P J Day (BBB_SRM.pdf)</td>
</tr></tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup>
<col class="label">
<col>
</colgroup>
<tbody valign="top"><tr>
<td class="label">[3]</td>
<td>BeagleBone Black Document Number 450-5500-001, Rev C, March 21, 2014 (BBB_SCH.pdf)</td>
</tr></tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup>
<col class="label">
<col>
</colgroup>
<tbody valign="top"><tr>
<td class="label"><a class="fn-backref" href="#id3">[4]</a></td>
<td>AM335x Sitara Processors, Rev I, Texas Instruments, SPRS7171 (am3358.pdf)</td>
</tr></tbody>
</table>
</div>
</div>
    </div>
    

</article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2016         <a href="mailto:soukthavy@yahoo.com">Soukthavy</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
