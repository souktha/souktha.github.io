<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Soukthavy Sopha</title><link>http://souktha.github.io/</link><description>Demo site</description><atom:link type="application/rss+xml" href="http://souktha.github.io/rss.xml" rel="self"></atom:link><language>en</language><lastBuildDate>Wed, 13 Dec 2017 18:05:28 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>OpenWRT (Chaos Calmer) on Linksys EA8300</title><link>http://souktha.github.io/misc/ea8300-openwrt/</link><dc:creator>Soukthavy</dc:creator><description>&lt;div&gt;&lt;p&gt;This blog is about installing the OpenWRT firmware into Linksys EA8300 Max-Stream AC200 Tri-Band Wi-Fi router. The firmware is
a customized version of OpenWRT Chaos Calmer for this platform. It serves as an alternative to the proprietary
firmware where one can further customizes it as needed.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://souktha.github.io/misc/ea8300-openwrt/"&gt;Read more…&lt;/a&gt; (8 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><guid>http://souktha.github.io/misc/ea8300-openwrt/</guid><pubDate>Fri, 17 Nov 2017 22:15:05 GMT</pubDate></item><item><title>RS(n,k) code HDL implementation</title><link>http://souktha.github.io/hardware/rs15_7_hw/</link><dc:creator>Soukthavy</dc:creator><description>&lt;div&gt;&lt;p&gt;This post is the implementation part of the my post on &lt;a class="reference external" href="http://souktha.github.io/misc/RS15_7_5"&gt;RS code workout&lt;/a&gt;
where I did some math workout on the RS forward-error-correcting code (FEC). I find
it to be simple enough to implement it in verilog that can eventually be synthesized for FPGA.
I choose the simplest algorithm to implement the RS (15,9,7) as outlined in my last post.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://souktha.github.io/hardware/rs15_7_hw/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>hardware</category><category>latex</category><category>mathjax</category><guid>http://souktha.github.io/hardware/rs15_7_hw/</guid><pubDate>Sat, 06 May 2017 14:47:03 GMT</pubDate></item><item><title>RS(n,k) code for burst error-correction work out</title><link>http://souktha.github.io/misc/RS15_7_5/</link><dc:creator>Soukthavy</dc:creator><description>&lt;div&gt;&lt;p&gt;This is a math workout problem that is the math part of my FPGA implementation of
another class of BCH code. The math workout of my earlier blog of a binary BCH code of
&lt;span class="math"&gt;\((n,k,d)=(15,7,5)\)&lt;/span&gt; is applicable to this class of code, the RS code
which is the non-binary version of BCH code. It will be based on the same
primitive polynomial &lt;span class="math"&gt;\(h(x)=1+x+x^4\)&lt;/span&gt; as the last exercise.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://souktha.github.io/misc/RS15_7_5/"&gt;Read more…&lt;/a&gt; (11 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>latex</category><category>mathjax</category><category>misc</category><guid>http://souktha.github.io/misc/RS15_7_5/</guid><pubDate>Sat, 22 Apr 2017 22:46:19 GMT</pubDate></item><item><title>Implementing BCH (15,7,5) FEC</title><link>http://souktha.github.io/hardware/bch15_7_5_hw/</link><dc:creator>Soukthavy</dc:creator><description>&lt;div&gt;&lt;p&gt;This post is the implementation part of the my post on &lt;a class="reference external" href="http://souktha.github.io/misc/bch15_7_5"&gt;Binary BCH (15,7,5) workout&lt;/a&gt;
where I did some math workout on the BCH forward-error-correcting code (FEC). I find
it to be simple enough to implement it in verilog that can eventually be synthesized for FPGA.
I choose the simplest algorithm for decoding the binary BCH (15,7,5) as outlined in my last post.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://souktha.github.io/hardware/bch15_7_5_hw/"&gt;Read more…&lt;/a&gt; (6 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>hardware</category><category>latex</category><category>mathjax</category><guid>http://souktha.github.io/hardware/bch15_7_5_hw/</guid><pubDate>Sat, 18 Mar 2017 00:17:42 GMT</pubDate></item><item><title>Binary BCH (15,7,5) work out</title><link>http://souktha.github.io/misc/bch15_7_5/</link><dc:creator>Soukthavy</dc:creator><description>&lt;div&gt;&lt;p&gt;This is a math workout problem that is the math part of my FPGA implementation of forward
error correction code (FEC). Build on my earlier blog of a Hamming cyclic code of
&lt;span class="math"&gt;\((n,k,d)=(15,11,3)\)&lt;/span&gt;, I will expand its capability to a binary
BCH &lt;span class="math"&gt;\((15,7,5), t=2\)&lt;/span&gt;  code based on the same primitive polynomial &lt;span class="math"&gt;\(h(x)=1+x+x^4\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://souktha.github.io/misc/bch15_7_5/"&gt;Read more…&lt;/a&gt; (10 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>latex</category><category>mathjax</category><category>misc</category><guid>http://souktha.github.io/misc/bch15_7_5/</guid><pubDate>Sun, 26 Feb 2017 22:46:19 GMT</pubDate></item><item><title>Create Wireless AP on Linux PC in 10 minutes</title><link>http://souktha.github.io/misc/create-ap-linuxpc/</link><dc:creator>Soukthavy</dc:creator><description>&lt;div&gt;&lt;p&gt;Creating a wireless access point aka WiFi AP is relatively easy. A typical PC
usually has at least one networking device or maybe two. One would be an Ethernet
device while the other would be a WiFi device. If the ethernet device is tethered
into the router already, this leaves WiFi device unused as in my case. Instead of
leaving it in a useless state, I choose to create a WiFi AP out of it.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://souktha.github.io/misc/create-ap-linuxpc/"&gt;Read more…&lt;/a&gt; (9 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>misc</category><guid>http://souktha.github.io/misc/create-ap-linuxpc/</guid><pubDate>Sun, 15 Jan 2017 19:14:05 GMT</pubDate></item><item><title>Simple Cyclic Hamming (15,11,3) FEC</title><link>http://souktha.github.io/hardware/cyclic_1_x_x4_hw/</link><dc:creator>Soukthavy</dc:creator><description>&lt;div&gt;&lt;p&gt;This post is the implementation part of the my post on &lt;a class="reference external" href="http://souktha.github.io/misc/cyclic_1_x_x4"&gt;simple cyclic Hamming code&lt;/a&gt;
where I did some math workout on this type of forward error-correction code (FEC). I am doing
it for fun since I think it is simple enough to implement it in FPGA. The generator
for this exercise is &lt;span class="math"&gt;\(g(x)=1+x+x4\)&lt;/span&gt; for an &lt;span class="math"&gt;\((n,k,d) \equiv (15,11,3)\)&lt;/span&gt; code.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://souktha.github.io/hardware/cyclic_1_x_x4_hw/"&gt;Read more…&lt;/a&gt; (7 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>hardware</category><category>latex</category><category>mathjax</category><guid>http://souktha.github.io/hardware/cyclic_1_x_x4_hw/</guid><pubDate>Thu, 22 Dec 2016 00:17:42 GMT</pubDate></item><item><title>Simple Cyclic Hamming codes</title><link>http://souktha.github.io/misc/cyclic_1_x_x4/</link><dc:creator>Soukthavy</dc:creator><description>&lt;div&gt;&lt;p&gt;This is a math workout problem that accompanied my FPGA implementation of forward error correction code (FEC). I choose to
make a simple implementation of &lt;span class="math"&gt;\((n,k,d)=(15,11,3)\)&lt;/span&gt; code using the primitive polynomial &lt;span class="math"&gt;\(h(x)=1+x+x^4\)&lt;/span&gt;.
This FEC will have be able to correct 1 bit error based on its minimum distance of 3. It is simple because it can be worked
out by hand and it would not take too long to implement in hardware.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://souktha.github.io/misc/cyclic_1_x_x4/"&gt;Read more…&lt;/a&gt; (8 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>latex</category><category>mathjax</category><category>misc</category><guid>http://souktha.github.io/misc/cyclic_1_x_x4/</guid><pubDate>Sat, 10 Dec 2016 22:46:19 GMT</pubDate></item><item><title>Zynq SPI slave stepper motor driver</title><link>http://souktha.github.io/software/zynq_spi_stepper_sw/</link><dc:creator>Soukthavy</dc:creator><description>&lt;div&gt;&lt;p&gt;The Linux SPI slave device driver is to enable user access to SPI slave stepper motor FPGA design in my other post
&lt;a class="reference external" href="http://souktha.github.io/hardware/zybo-spi-stepper"&gt;http://souktha.github.io/hardware/zybo-spi-stepper&lt;/a&gt; . This is the software part of that implementation on the Zybo Zynq7000.
I reuse the original SPI slave I wrote earlier and expand its functionality a little bit more so that I can send
the step count to the stepper motor.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://souktha.github.io/software/zynq_spi_stepper_sw/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>software</category><guid>http://souktha.github.io/software/zynq_spi_stepper_sw/</guid><pubDate>Thu, 17 Nov 2016 00:40:47 GMT</pubDate></item><item><title>SPI slave stepper motor with Zybo</title><link>http://souktha.github.io/hardware/zybo-spi-stepper/</link><dc:creator>Soukthavy</dc:creator><description>&lt;div&gt;&lt;p&gt;My previous blog was to create the SPI slave device on Programmable Logic (PL) side of the Zynq7000 where it
can be interconnected and can be accessible by the Processing System (PS) side of this SoC and I achieved the
result I expected. Since that blog was only for validating my SPI slave design to be coherent with the rest of the
system without doing much useful work, I would like to extend it so that I can make it do a bit more useful work.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://souktha.github.io/hardware/zybo-spi-stepper/"&gt;Read more…&lt;/a&gt; (14 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>hardware</category><guid>http://souktha.github.io/hardware/zybo-spi-stepper/</guid><pubDate>Sat, 12 Nov 2016 15:38:09 GMT</pubDate></item></channel></rss>